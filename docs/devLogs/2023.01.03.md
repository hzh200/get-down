Javascript 里对基本类型和引用类型的赋值拷贝都是值拷贝，想对引用的对象拷贝，又分为浅拷贝和深拷贝，浅拷贝指的就是只拷贝对象的直属属性，比如  `[...array]` 和 `{..obj}`，想要深拷贝，需要进行递归对每个子对象进行浅拷贝，和之前全局 setting 中对整个对象做代理是一样的方法。

Webpack [externals](https://webpack.docschina.org/configuration/externals/) 的作用是防止将某些 import 的模块打包到 bundle 中，在运行时再去从外部获取这些扩展依赖 (external dependencies)。

而且 Webpack 应该就是在 node 环境下使用的，因为示例中用的都是 require。

测试下 Wireshark 非常慢，用 FDM 测试了一下也是一样的，所以应该是我本地网络的问题，网络和几天前相比发生了变动，因为一直上不去的 NGA 也能上去了。

暂停时全局依然可以捕获到这样的错误：

```error
(node:836) UnhandledPromiseRejectionWarning: TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))    at RangeDownloader.downloadRange (C:\Users\bravehzh\Codebase\http-downloader\src\main\downloaders\range_downloader.js:108:16)    at process.processTicksAndRejections (node:internal/process/task_queues:96:5)
(node:836) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)
```

这是划分 range 和把 downloader 放入 map 之间的操作中，httpRequest 抛出的错误我已经获取了，那或许是 handlePromise 抛出的错误我没有捕获到，也就是需要再调用 downloadRange 的位置做错误处理，即不 await 它，只是抛出一个异步函数的执行实例，但也要做异常的捕获，对其他的类似的 async 函数，也应该这样处理。

模块执行顺序：我把 setting 模块和 log 模块放到 util 模块下，读取 Log 的时候，加上对 isDev 的判断后，程序会报错：

```error
App threw an error during load
TypeError: (0 , utils_1.readSetting) is not a function
```

这是因为程序初始化的第一步用到 handlePromise，也是 util 包的功能，我的 util 模块对子模块 log 的导入再第一行，使用 handlePromise 的时候，程序会执行 util 模块，第一步就是执行 log 模块，在 log 里加上了对 isDev 的判断，程序又会执行 global 模块，在 global 模块里，globalSetting 的导入在 isDev 的前面，globalSetting 需要用到 setting 模块的功能，而由于 setting 在 log 后面，还没有被初始化，在加载程序的时候就会报错。我用输出测试了一下：

```javascript
import { app, BrowserWindow, ipcMain, IpcMainEvent } from 'electron'
import { initialize, enable } from '@electron/remote/main'
import * as path from 'node:path'
console.log('111111')
import { Scheduler } from './scheduler'
console.log('222222')
import { initPersistence } from './persistence'
import { Log } from '../share/utils'
import { SRC_PATH } from '../../configs/path'
import { isDev } from '../share/global'
```

最后发现是在导入模块的阶段，而且应该是 scheduler 中对 util 模块导入时出现的错误。

修改错误只需要把被导入的模块放在前面。在我这里是在 util/index 中，把对 setting 的导入放在对 log 的导入前面。

只导入 isDev 不使用的话，不会出现上述问题，我估计是 Webpack 把无效引用给删除了。

Electron 一直提示又渲染的错误，tbody 附近有空格：

```error
validateDOMNesting(...): Whitespace text nodes cannot appear as a child of <tbody>. Make sure you don't have any extra whitespace between tags on each line of your source code.
```

我最开始找各个 tr 的空格，我还以为因为 createdAt 是空的，结果发现是 jsx 语法中，我为了添加一个注释，在 `<tbody>` 和 `{/* */}` 之间加了一个空格，就是这个空格出发了错误。

时间处理的问题上，Javascript 可以自动读取各种各样的时间格式，将时间字符串分割成 Unix 标准中的年月日时分秒等等，以供后续处理，我之前做自回归的数据预处理，对时间的处理需要自己设定好时间字符串的格式对字符串进行分割。

